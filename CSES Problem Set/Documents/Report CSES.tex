\documentclass{article}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{enumitem}
\usepackage{tikz}
\usetikzlibrary{graphs}
\usepackage[utf8]{inputenc}
\usepackage[T5]{fontenc}
\usepackage[vietnamese]{babel}

\begin{document}
	
	\section{BuildingRoads}
	
	Cho $N$ thành phố được đánh số từ $1$ đến $N$, và $M$ con đường đã xây giữa một số cặp thành phố. Mỗi con đường nối hai thành phố $a$ và $b$. 
	
	Mục tiêu là thêm vào một số tối thiểu các con đường sao cho mọi thành phố đều nằm trong cùng một thành phần liên thông.
		
	\subsection*{1. Cấu trúc DSU}
	Mỗi thành phố ban đầu là một tập riêng biệt.
	
	\begin{itemize}
		\item Mảng \texttt{ds[i]} lưu thông tin về gốc của tập chứa thành phố $i$.
		\item Hàm \texttt{find(u)} trả về gốc của tập chứa $u$, đồng thời áp dụng \textit{path compression}:
		\[
		\text{find}(u) = 
		\begin{cases}
			u & \text{nếu } ds[u] < 0 \\
			\text{find}(ds[u]) & \text{ngược lại}
		\end{cases}
		\]
		\item Hàm \texttt{merge(u, v)} hợp nhất hai tập nếu $u$ và $v$ thuộc hai tập khác nhau:
		\[
		\text{merge}(u, v) = 
		\begin{cases}
			\text{false} & \text{nếu } \text{find}(u) = \text{find}(v) \\
			\text{gộp hai tập và trả về true} & \text{ngược lại}
		\end{cases}
		\]
	\end{itemize}
	
	\subsection*{2. Thuật toán chính}
	\begin{enumerate}
		\item Khởi tạo: \texttt{ds[i] = -1} với mọi $i$ từ $1$ đến $N$.
		\item Với mỗi cạnh $(a, b)$ đầu vào, gọi \texttt{merge(a, b)} để nối các thành phố đã liên thông.
		\item Duyệt từ $i = 1$ đến $N - 1$:
		\begin{itemize}
			\item Nếu \texttt{merge(i, i+1)} thành công, nghĩa là $i$ và $i+1$ chưa liên thông, thì thêm cạnh $(i, i+1)$ vào danh sách kết quả.
		\end{itemize}
		\item In ra số đường thêm vào và danh sách các đường đó.
	\end{enumerate}
	
	\subsection*{3. Độ phức tạp}
	Với kỹ thuật \textit{path compression} và \textit{union by size}, mỗi phép \texttt{find} hay \texttt{merge} có độ phức tạp gần $\mathcal{O}(1)$ (chính xác là $\mathcal{O}(\alpha(N))$ với $\alpha$ là hàm nghịch đảo Ackermann).
	
	Tổng độ phức tạp:
	\[
	\mathcal{O}(M \cdot \alpha(N) + N \cdot \alpha(N)) \approx \mathcal{O}(N)
	\]
	
	\section{CountingRooms}
	\subsection*{Mô tả bài toán}
	Cho một mê cung dưới dạng lưới $N \times M$ với mỗi ô là:
	\begin{itemize}
		\item \texttt{\char`\.} — ô trống có thể đi vào.
		\item \texttt{\char`\#} — tường không thể đi qua.
	\end{itemize}
	
	Hai ô trống được xem là \textbf{liên thông} nếu chúng kề nhau theo hướng lên, xuống, trái, hoặc phải.
	
	\textbf{Yêu cầu:} Đếm số vùng liên thông các ô trống — gọi là \textit{số phòng}.
	\subsection*{Ý tưởng thuật toán}
	
	\begin{enumerate}
		\item Duyệt toàn bộ ma trận.
		\item Với mỗi ô chưa được thăm và là ô trống \texttt{'.'}, thực hiện thuật toán DFS để đánh dấu tất cả các ô trong vùng liên thông.
		\item Mỗi lần gọi DFS tương ứng với một phòng mới.
	\end{enumerate}
	
	\subsection*{Hàm DFS}
	Giả sử đang ở ô $(x, y)$, đánh dấu là đã thăm:
	\[
	\text{visited}[x][y] \leftarrow \text{true}
	\]
	Sau đó, thử di chuyển sang 4 hướng:
	\[
	(x + 1, y),\ (x - 1, y),\ (x, y + 1),\ (x, y - 1)
	\]
	Nếu ô mới hợp lệ, không phải tường, chưa được thăm, thì tiếp tục gọi đệ quy.
	
	\subsection*{Độ phức tạp thời gian}
	Mỗi ô được thăm nhiều nhất 1 lần, nên tổng thời gian là:
	\[
	\mathcal{O}(N \cdot M)
	\]

	
\end{document}
